# 深入调研 v3 结果分析

## 调研时间: 2026-02-06

---

## 🔥 重大发现

### 1. 忘记密码流程 XHR 复用 — ⚠️ 异常结果

忘记密码流程用的也是 MI613e RPC，但 XHR 复用测试出现了意外结果：

- `testxhr111@gmail.com`（不存在）→ 返回 `LOGIN_CHALLENGE`（误判为存在！）
- `999999@gmail.com`（存在）→ 返回 `LOGIN_CHALLENGE`（正确）

**分析：** 忘记密码页面刷新后，XHR 复用的模板中 session 签名仍然绑定了 `000001@gmail.com` 的上下文。Google 后端可能忽略了邮箱替换，继续返回原始账号的结果。

**结论：** 忘记密码流程的 MI613e 也不能 XHR 复用。和登录页一样，session 签名是一次性的。

### 2. Cookie 导出 + 独立 HTTP — ❌ 全部超时

4 个独立 HTTP 请求全部 timeout（15s）。

**可能原因：**
- Google 检测到 TLS 指纹不是真实浏览器（Node.js https 的 TLS 指纹和 Chrome 不同）
- 连接被 Google 的 WAF 静默丢弃
- Cookie 不够完整（只有 4 个 cookies）

**结论：** 纯 Node.js https 无法直接发请求。需要 curl-impersonate 或类似工具来模拟浏览器 TLS 指纹。

### 3. 登录页 DOM 并行 — 速度太慢

| 模式 | 速度 | 评价 |
|------|------|------|
| 单 context | 0.17 req/s | 太慢，不实用 |
| 3 context 并行 | 0.48 req/s | 仍然太慢 |

每次检查需要：打开登录页(~2s) + 填邮箱 + 点击 + 等响应(~3s) = ~5s/次。
即使 3 并行也只有 0.48 req/s，远不如注册页 API 模式。

**结论：** 登录页 DOM 模式不值得投入。注册页 API 模式是更好的选择。

**注意：** `para2b@gmail.com` 被判定为 EXISTS，`999999@gmail.com` 被判定为 UNKNOWN。这说明 Google 可能对频繁查询的 IP 返回假阳性/假阴性。

### 4. 注册页多 context 并行 — ⭐ 最有价值的发现

| 间隔 | 请求数 | 耗时 | 速度 | 降级 |
|------|--------|------|------|------|
| 500ms | 10 | 3.8s | **2.6 req/s** | 0 |
| 300ms | 10 | 2.9s | **3.4 req/s** | 0 |
| 200ms | 10 | 2.3s | **4.3 req/s** | 0 |

**关键发现：**
- 2 个 context 并行，200ms 间隔，**零降级**，达到 4.3 req/s
- 这比单 context 500ms 间隔的 2 req/s 提升了 **2.15x**
- Session 建立耗时 37.1s（2 个 session），但建立后可以长期使用

**推算：**
- 3 个 context × 200ms 间隔 ≈ **6-7 req/s**
- 4 个 context × 200ms 间隔 ≈ **8-9 req/s**（需要验证 IP 级限制）

---

## 方案优先级更新

### ✅ 立即执行（确定性高）

| # | 方案 | 预期速度 | 实现成本 |
|---|------|---------|---------|
| 1 | **多 context 并行 (3个)** | 6-7 req/s | 1 小时 |
| 2 | **缩短间隔到 200ms** | +50% | 5 分钟 |
| 3 | **Session 池化** | 消除停工 | 1 小时 |

### 🔬 值得继续探索

| # | 方案 | 备注 |
|---|------|------|
| 4 | curl-impersonate | 解决 TLS 指纹问题，脱离浏览器 |
| 5 | Identity Toolkit (自有 Key) | 需要创建 Firebase 项目 |
| 6 | 代理轮换 | N × 基础速度 |

### ❌ 不推荐

| # | 方案 | 原因 |
|---|------|------|
| - | 登录页 DOM 并行 | 0.48 req/s，太慢 |
| - | 忘记密码 XHR 复用 | Session 签名一次性，不可复用 |
| - | Cookie + Node.js https | TLS 指纹被检测，全部超时 |

---

## 最优执行计划

### 目标：从 2 req/s → 6-8 req/s

**Step 1：改造 checker-api-fast.js（1-2 小时）**
```
1. 支持 N 个 context 并行（默认 3）
2. 间隔从 500ms 缩短到 250ms（保守起见不用 200ms）
3. 每个 context 独立的 session 管理
4. 用户名分配：round-robin 分配给各 context
5. 探针检测：每个 context 独立探针
```

**预期效果：**
- 3 context × 250ms 间隔 ≈ 3 × 4 = **~6 req/s**（保守估计）
- 剩余 ~997,000 个用户名 / 6 req/s = **~46 小时**
- 比原来的 138 小时减少 **67%**

**Step 2：Session 池化（1 小时）**
- 后台预热 session，降级时无缝切换
- 消除 session 刷新的 ~20s 停工时间
- 预期额外提升 10-15%

**Step 3：如果需要更快**
- 接入代理轮换（每个 IP 独立限速）
- 5 个 IP × 6 req/s = **30 req/s** → ~9 小时完成
